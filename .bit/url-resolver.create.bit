name: .bithub-unified

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["Resilient Smart Work AI Pipeline", "Dynamic Resilient AI Pipeline"]
    types: [completed]
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

permissions:
  contents: write
  actions: write
  packages: write

jobs:
  secondary-recovery:
    name: ".bit: Secondary Recovery Job (with Bit.Hub Audit)"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: ".bit: Checkout repository"
        uses: actions/checkout@v4
      - name: ".bit: Ensure context.json exists"
        run: |
          mkdir -p .bit
          if [ ! -f ".bit/context.json" ]; then
            echo '{"event":"manual","timestamp":"'"$(date -u +%FT%TZ)"'"}' > .bit/context.json
            echo "[.bit] Created default context.json"
          fi
      - name: ".bit: OPA/Bit.Hub Policy Gate"
        uses: open-policy-agent/setup-opa@v2
      - name: ".bit: Evaluate Step Policy"
        run: |
          opa eval --data .bit/policy \
            --input .bit/context.json \
            --format pretty \
            'data.bithub.secondary_recovery.allow'
      - name: ".bit: Ensure recovery script present"
        run: |
          if [ ! -x "./secondary-recovery.sh" ]; then
            echo "::error::Recovery script 'secondary-recovery.sh' is missing or not executable."
            exit 1
          fi
      - name: Setup Go environment
        uses: actions/setup-go@v5.5.0
        with:
          go-version: '1.22.x'
          check-latest: true
          cache: true
      - name: ".bit: Run Secondary Recovery Task"
        id: secondary_recovery
        continue-on-error: true
        run: |
          echo "Running .bit secondary recovery logic..."
          ./secondary-recovery.sh
      - name: ".bit: Handle Recovery Failure"
        if: steps.secondary_recovery.outcome == 'failure'
        run: |
          echo "::warning::Secondary recovery failed. Bit.Hub fallback engaged."
          echo "Review logs and consider manual audit/intervention as per Bit.Hub protocol."
      - name: ".bit: Upload Recovery Logs"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: .bit-recovery-logs
          path: |
            "./recovery*.log"
            "./logs/"
            "!./logs/exclude-this.log"
      - name: ".bit: Notify on Recovery Events"
        if: failure()
        run: |
          echo "Sending .bit/Bit.Hub-compliant notifications for recovery failure."
          # Optional: Integrate with Slack, Teams, or email APIs per company compliance here.
      - name: ".bit: Job Summary & Bit.Hub Compliance Log"
        run: |
          if [ "${{ steps.secondary_recovery.outcome }}" = "success" ]; then
            echo "### .bit secondary recovery completed **successfully** :white_check_mark:" >> $GITHUB_STEP_SUMMARY
          else
            echo "### .bit secondary recovery **failed** :x:" >> $GITHUB_STEP_SUMMARY
            echo "Logs and fallback info uploaded as workflow artifacts." >> $GITHUB_STEP_SUMMARY
          fi
          echo "Bit.Hub compliance log completed at $(date -u)."

  lang-surface:
    strategy:
      fail-fast: false
      matrix:
        include:
          - lang: aln
            runs_on: ubuntu-latest
            image_prefix: aln
            test_cmd: ".bithub/scripts/lang-test-aln.sh ./aln/tests"
            platforms: linux/amd64
          - lang: batchfile
            runs_on: windows-latest
            image_prefix: batch
            test_cmd: ".bithub\\scripts\\lang-test-batchfile.bat .\\batch\\tests"
            platforms: windows/amd64
          - lang: lisp
            runs_on: ubuntu-latest
            image_prefix: lisp
            test_cmd: ".bithub/scripts/lang-test-lisp.sh ./lisp/tests"
            platforms: linux/amd64
    runs-on: ${{ matrix.runs_on }}
    timeout-minutes: 90
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.BITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 1
          clean: true
      - name: Tooling (Linux)
        if: runner.os == 'Linux'
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq
          if ! command -v yq >/dev/null; then
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq
          fi
      - name: Tooling (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ProgressPreference='SilentlyContinue'
          choco install jq -y | Out-Null
          if (-not (Get-Command yq.exe -ErrorAction SilentlyContinue)) {
            Invoke-WebRequest https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_windows_amd64.exe -OutFile "$env:USERPROFILE\yq.exe"
            Copy-Item "$env:USERPROFILE\yq.exe" "C:\Windows\System32\yq.exe"
          }
      - name: Ensure test script exists
        run: |
          if [ ! -f "${{ matrix.test_cmd%% * }}" ]; then
            echo "::error::Test script not found: ${{ matrix.test_cmd%% * }}"
            exit 1
          fi
        shell: bash
      - name: Execute native language tests
        run: ${{ matrix.test_cmd }}
        shell: bash
      - name: Build/test/push images with .bit-image
        if: runner.os == 'Linux'
        uses: ./.github/actions/.bit-image
        with:
          registry: ghcr.io
          registry-username: ${{ github.repository_owner }}
          registry-password: ${{ secrets.BITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          image-prefix: ${{ matrix.image_prefix }}
          platforms: ${{ matrix.platforms }}
          test-command: ${{ matrix.test_cmd }}
          provenance: 'true'
          sbom: 'true'
          sign: 'false'
          push: ${{ github.event_name == 'push' && github.ref_name == 'main' }}
      - name: Detect build outputs
        id: detect
        uses: ./.github/actions/.bit-detect-outputs
        with:
          globs: |
            **/dist/**
            **/build/**
            **/out/**
            **/target/**
            **/bin/**
            **/release/**
      - name: Upload language artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: bithub-${{ matrix.lang }}-${{ github.run_number }}-${{ github.sha }}
          path: ${{ steps.detect.outputs.paths }}
          if-no-files-found: warn
          retention-days: 14
          compression-level: 6
          overwrite: false
          include-hidden-files: true

  adapt-overhaul:
    needs: [ lang-surface ]
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.BITHUB_TOKEN || secrets.GITHUB_TOKEN }}
      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
      - name: Adapt existing workflows
        run: |
          mkdir -p .bithub/adapted
          for wf in .github/workflows/*.yml; do
            [ "$(basename "$wf")" = ".bithub-unified.yml" ] && continue
            yq eval '
              (.jobs.*.steps[] | select(.uses == "actions/upload-artifact@"*).with.name) |=
                (. + "-${{ github.run_number }}-${{ github.sha }}") |
              (.jobs.*.steps[] | select(has("run")) .run) |=
                ("set -euo pipefail\nretry() { a=$1; d=$2; shift 2; n=0; until \"$@\"; do n=$((n+1)); [ $n -ge $a ] && return 1; sleep $(( d * 2**(n-1) )); done; }\n" + .)
            ' "$wf" > ".bithub/adapted/$(basename "$wf")"
          done
          cp .bithub/adapted/*.yml .github/workflows/ || true
      - name: Commit adapted workflows
        run: |
          git config user.name "bithub-bot"
          git config user.email "bithub-bot@users.noreply.github.com"
          git add .github/workflows/*.yml
          git commit -m "[.bithub] adaptive enhancement: dynamic artifacts + retry wrappers" || echo "No changes"
          git push || true
